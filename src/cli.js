#!/usr/bin/env node

/**
 * NicheBot CLI
 * Commands:
 *   nichebot bootstrap [options]
 *   nichebot setup
 *   nichebot doctor [--json]
 *   nichebot start
 *   nichebot stop
 *   nichebot service <install|uninstall|start|stop|restart|status|logs|doctor> [--json]
 *   nichebot backup [list|verify|prune]
 *   nichebot restore <id|--latest>
 *   nichebot db [doctor|optimize]
 *   nichebot (defaults to start)
 */

const fs = require('fs');
const path = require('path');
const readline = require('node:readline/promises');
const { stdin, stdout } = require('node:process');
const dotenv = require('dotenv');

const {
    runtimeHome,
    envPath,
    dataDir,
    dbPath,
    logsDir,
    backupsDir,
    ensureRuntimeDirs,
    findLegacyPaths,
} = require('./runtime/paths');
const { getLockStatus, isPidRunning } = require('./runtime/lock');
const {
    listBackups,
    getLatestBackup,
    createRuntimeBackup,
    verifyBackup,
    restoreRuntimeBackup,
    pruneBackups,
} = require('./runtime/backup');
const { inspectDatabase, optimizeDatabase } = require('./db/maintenance');
const { runBootstrap } = require('./runtime/bootstrap');
const {
    detectServicePlatform,
    installService,
    uninstallService,
    startService,
    stopService,
    restartService,
    statusService,
    logsService,
    doctorService,
} = require('./runtime/service');
const {
    config,
    loadEnv,
    reloadConfig,
    validateConfig,
    formatValidationReport,
} = require('./config');

const PROVIDER_MODELS = {
    openai: 'gpt-4o-mini',
    anthropic: 'claude-sonnet-4-20250514',
    deepseek: 'deepseek-chat',
};

function nowStamp() {
    return new Date().toISOString().replace(/[:.]/g, '-');
}

function pathEquals(a, b) {
    return path.resolve(a) === path.resolve(b);
}

function parseEnvFile(filePath) {
    if (!fs.existsSync(filePath)) return {};
    try {
        const raw = fs.readFileSync(filePath, 'utf8');
        return dotenv.parse(raw);
    } catch {
        return {};
    }
}

function quoteEnvValue(value) {
    const stringValue = String(value ?? '');
    if (stringValue === '') return '';
    if (/[\s#"'`]/.test(stringValue)) {
        return JSON.stringify(stringValue);
    }
    return stringValue;
}

function buildEnvFileContent(values) {
    const lines = [
        '# ===================================',
        '# NicheBot Runtime Configuration',
        '# Generated by: nichebot setup',
        '# Runtime home: ~/.nichebot (or $NICHEBOT_HOME)',
        '# ===================================',
        '',
        '# --- TELEGRAM (REQUIRED) ---',
        '# Get your bot token from @BotFather',
        `TELEGRAM_BOT_TOKEN=${quoteEnvValue(values.TELEGRAM_BOT_TOKEN)}`,
        '# Your Telegram user ID (required in strict single-user mode)',
        `TELEGRAM_ALLOWED_USER_ID=${quoteEnvValue(values.TELEGRAM_ALLOWED_USER_ID)}`,
        '',
        '# --- LLM PROVIDER (REQUIRED) ---',
        '# Options: openai, anthropic, deepseek',
        `LLM_PROVIDER=${quoteEnvValue(values.LLM_PROVIDER)}`,
        '',
        '# OpenAI',
        `OPENAI_API_KEY=${quoteEnvValue(values.OPENAI_API_KEY)}`,
        `OPENAI_MODEL=${quoteEnvValue(values.OPENAI_MODEL)}`,
        '',
        '# Anthropic Claude',
        `ANTHROPIC_API_KEY=${quoteEnvValue(values.ANTHROPIC_API_KEY)}`,
        `ANTHROPIC_MODEL=${quoteEnvValue(values.ANTHROPIC_MODEL)}`,
        '',
        '# DeepSeek',
        `DEEPSEEK_API_KEY=${quoteEnvValue(values.DEEPSEEK_API_KEY)}`,
        `DEEPSEEK_MODEL=${quoteEnvValue(values.DEEPSEEK_MODEL)}`,
        '',
        '# --- TWITTER/X (OPTIONAL) ---',
        `TWITTER_API_KEY=${quoteEnvValue(values.TWITTER_API_KEY)}`,
        `TWITTER_API_SECRET=${quoteEnvValue(values.TWITTER_API_SECRET)}`,
        `TWITTER_ACCESS_TOKEN=${quoteEnvValue(values.TWITTER_ACCESS_TOKEN)}`,
        `TWITTER_ACCESS_SECRET=${quoteEnvValue(values.TWITTER_ACCESS_SECRET)}`,
        '',
        '# --- GENERAL SETTINGS ---',
        `DEFAULT_LANGUAGE=${quoteEnvValue(values.DEFAULT_LANGUAGE)}`,
        `MAX_DAILY_POSTS=${quoteEnvValue(values.MAX_DAILY_POSTS)}`,
        '',
        '# --- PROMPT & QUALITY ---',
        '# Supported prompt template versions: v1',
        `PROMPT_TEMPLATE_VERSION=${quoteEnvValue(values.PROMPT_TEMPLATE_VERSION)}`,
        '# Auto scheduler publish threshold (0-100)',
        `QUALITY_MIN_AUTO_PUBLISH_SCORE=${quoteEnvValue(values.QUALITY_MIN_AUTO_PUBLISH_SCORE)}`,
        '',
        '# --- RUNTIME ---',
        `LOG_LEVEL=${quoteEnvValue(values.LOG_LEVEL)}`,
        `TZ=${quoteEnvValue(values.TZ)}`,
        `NODE_ENV=${quoteEnvValue(values.NODE_ENV)}`,
        '',
    ];

    return `${lines.join('\n')}\n`;
}

function printHeader() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         ü§ñ NicheBot CLI             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);
}

function printHelp() {
    printHeader();
    console.log('Usage: nichebot <command>\n');
    console.log('Commands:');
    console.log('  bootstrap [opts] Bootstrap global install + setup + doctor');
    console.log('  setup           Interactive setup wizard');
    console.log('  doctor [--json] Check runtime/config status without starting the bot');
    console.log('  start           Validate config and start bot runtime');
    console.log('  stop            Stop running bot process (if lock is active)');
    console.log('  service <cmd>   Manage background service (install/start/status/...)');
    console.log('  backup          Create runtime backup');
    console.log('  backup list     List available backups');
    console.log('  backup verify   Verify backup integrity');
    console.log('  backup prune    Prune old backups by retention');
    console.log('  restore <id>    Restore runtime backup');
    console.log('  db doctor       Check SQLite integrity and DB stats');
    console.log('  db optimize     Run checkpoint + vacuum + optimize');
    console.log('  help            Show this help');
    console.log('');
    console.log('Bootstrap options:');
    console.log('  --non-interactive  Do not launch setup wizard');
    console.log('  --skip-install     Skip install:global step');
    console.log('  --skip-setup       Skip setup step');
    console.log('  --skip-doctor      Skip doctor step');
    console.log('  --json             Output machine-readable result');
    console.log('');
    console.log('Service commands:');
    console.log('  install | uninstall | start | stop | restart | status | logs | doctor');
    console.log('');
    console.log('Runtime paths:');
    console.log(`  home: ${runtimeHome}`);
    console.log(`  env:  ${envPath}`);
    console.log(`  db:   ${dbPath}`);
    console.log(`  lock: ${getLockStatus().path}`);
    console.log(`  bak:  ${backupsDir}`);
    console.log('');
}

function backupFile(filePath) {
    if (!fs.existsSync(filePath)) return null;
    const backupPath = `${filePath}.backup-${nowStamp()}`;
    fs.copyFileSync(filePath, backupPath);
    return backupPath;
}

function migrateLegacyIfNeeded() {
    ensureRuntimeDirs();
    const legacy = findLegacyPaths();
    const report = {
        migrated: false,
        env: null,
        db: null,
    };

    const shouldMigrateFromLegacy = !fs.existsSync(envPath) && legacy.hasLegacyEnv;
    if (!shouldMigrateFromLegacy) {
        return report;
    }

    const canMigrateEnv =
        shouldMigrateFromLegacy &&
        !pathEquals(legacy.legacyEnvPath, envPath);

    if (canMigrateEnv) {
        const backupPath = backupFile(legacy.legacyEnvPath);
        fs.copyFileSync(legacy.legacyEnvPath, envPath);
        report.migrated = true;
        report.env = {
            from: legacy.legacyEnvPath,
            to: envPath,
            backup: backupPath,
        };
    }

    const canMigrateDb =
        shouldMigrateFromLegacy &&
        legacy.hasLegacyDb &&
        !fs.existsSync(dbPath) &&
        !pathEquals(legacy.legacyDbPath, dbPath);

    if (canMigrateDb) {
        if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
        const backupPath = backupFile(legacy.legacyDbPath);
        fs.copyFileSync(legacy.legacyDbPath, dbPath);
        report.migrated = true;
        report.db = {
            from: legacy.legacyDbPath,
            to: dbPath,
            backup: backupPath,
        };
    }

    if (report.migrated) {
        console.log('Migration report:');
        if (report.env) {
            console.log(`- .env migrated: ${report.env.from} -> ${report.env.to}`);
            if (report.env.backup) console.log(`  backup: ${report.env.backup}`);
        }
        if (report.db) {
            console.log(`- DB migrated: ${report.db.from} -> ${report.db.to}`);
            if (report.db.backup) console.log(`  backup: ${report.db.backup}`);
        }
        console.log('');
    }

    return report;
}

async function promptInput(rl, prompt, options = {}) {
    const { defaultValue = '', required = false, validator = null, mask = false } = options;

    while (true) {
        const suffix = defaultValue
            ? (mask ? ' [saved]' : ` [${defaultValue}]`)
            : '';
        let raw;
        if (mask) {
            rl.pause();
            try {
                raw = await promptHiddenInput(`${prompt}${suffix}: `);
            } finally {
                rl.resume();
            }
        } else {
            raw = await rl.question(`${prompt}${suffix}: `);
        }
        const value = (raw || defaultValue || '').trim();

        if (required && !value) {
            console.log('This field is required.');
            continue;
        }

        if (validator) {
            const validation = validator(value);
            if (validation !== true) {
                console.log(validation || 'Invalid value.');
                continue;
            }
        }

        if (mask && value) {
            return value;
        }
        return value;
    }
}

function promptHiddenInput(prompt) {
    return new Promise((resolve, reject) => {
        if (!stdin.isTTY || !stdout.isTTY) {
            reject(new Error('Secret prompt requires TTY.'));
            return;
        }

        stdout.write(prompt);
        let value = '';

        function cleanup() {
            stdin.removeListener('data', onData);
            if (stdin.isTTY) stdin.setRawMode(false);
            stdin.pause();
        }

        function onData(chunk) {
            const text = String(chunk || '');
            for (const ch of text) {
                if (ch === '\r' || ch === '\n') {
                    stdout.write('\n');
                    cleanup();
                    resolve(value);
                    return;
                }

                if (ch === '\u0003') {
                    cleanup();
                    reject(new Error('Prompt interrupted by user.'));
                    return;
                }

                if (ch === '\u007f' || ch === '\b' || ch === '\u0008') {
                    if (value.length > 0) value = value.slice(0, -1);
                    continue;
                }

                if (ch >= ' ') {
                    value += ch;
                }
            }
        }

        stdin.resume();
        stdin.setRawMode(true);
        stdin.on('data', onData);
    });
}

function validateProvider(value) {
    const normalized = String(value || '').trim().toLowerCase();
    return ['openai', 'anthropic', 'deepseek'].includes(normalized);
}

function getProviderKeyField(provider) {
    if (provider === 'openai') return 'OPENAI_API_KEY';
    if (provider === 'anthropic') return 'ANTHROPIC_API_KEY';
    return 'DEEPSEEK_API_KEY';
}

async function runSetupWizard() {
    if (!canPromptUser()) {
        console.error('Setup wizard requires an interactive terminal (TTY).');
        process.exitCode = 1;
        return;
    }

    ensureRuntimeDirs();
    const current = parseEnvFile(envPath);

    printHeader();
    console.log('Interactive setup wizard');
    console.log(`Runtime home: ${runtimeHome}`);
    console.log(`Config file : ${envPath}`);
    console.log('');

    const rl = readline.createInterface({ input: stdin, output: stdout });

    try {
        const language = await promptInput(rl, 'Default language (tr/en)', {
            defaultValue: (current.DEFAULT_LANGUAGE || '').toLowerCase() || 'en',
            required: true,
            validator: (v) => (['tr', 'en'].includes(v.toLowerCase()) ? true : 'Use "tr" or "en".'),
        });

        const telegramToken = await promptInput(rl, 'Telegram bot token', {
            defaultValue: current.TELEGRAM_BOT_TOKEN || '',
            required: true,
            mask: true,
        });

        const telegramAllowedUserId = await promptInput(rl, 'Telegram allowed user id', {
            defaultValue: current.TELEGRAM_ALLOWED_USER_ID || '',
            required: true,
            validator: (v) => (/^\d+$/.test(v) ? true : 'Use a numeric Telegram user id.'),
        });

        const provider = (await promptInput(rl, 'LLM provider (openai/anthropic/deepseek)', {
            defaultValue: (current.LLM_PROVIDER || 'deepseek').toLowerCase(),
            required: true,
            validator: (v) => (validateProvider(v) ? true : 'Use one of: openai, anthropic, deepseek.'),
        })).toLowerCase();

        const providerKeyField = getProviderKeyField(provider);
        const providerKey = await promptInput(rl, `${providerKeyField}`, {
            defaultValue: current[providerKeyField] || '',
            required: true,
            mask: true,
        });

        const modelField = `${provider.toUpperCase()}_MODEL`;
        const model = await promptInput(rl, `${modelField}`, {
            defaultValue: current[modelField] || PROVIDER_MODELS[provider],
            required: true,
        });

        console.log('\nTwitter setup is optional. Leave blank to skip.');
        const twitterApiKey = await promptInput(rl, 'TWITTER_API_KEY', {
            defaultValue: current.TWITTER_API_KEY || '',
            mask: true,
        });
        const twitterApiSecret = await promptInput(rl, 'TWITTER_API_SECRET', {
            defaultValue: current.TWITTER_API_SECRET || '',
            mask: true,
        });
        const twitterAccessToken = await promptInput(rl, 'TWITTER_ACCESS_TOKEN', {
            defaultValue: current.TWITTER_ACCESS_TOKEN || '',
            mask: true,
        });
        const twitterAccessSecret = await promptInput(rl, 'TWITTER_ACCESS_SECRET', {
            defaultValue: current.TWITTER_ACCESS_SECRET || '',
            mask: true,
        });

        const maxDailyPosts = await promptInput(rl, 'MAX_DAILY_POSTS', {
            defaultValue: current.MAX_DAILY_POSTS || '5',
            required: true,
            validator: (v) => (/^\d+$/.test(v) && Number(v) > 0 ? true : 'Use a positive integer.'),
        });
        const promptTemplateVersion = await promptInput(rl, 'PROMPT_TEMPLATE_VERSION (v1)', {
            defaultValue: (current.PROMPT_TEMPLATE_VERSION || 'v1').toLowerCase(),
            required: true,
            validator: (v) => (/^v\d+$/.test(v.toLowerCase()) ? true : 'Use format like v1.'),
        });
        const qualityMinAutoPublishScore = await promptInput(rl, 'QUALITY_MIN_AUTO_PUBLISH_SCORE (0-100)', {
            defaultValue: current.QUALITY_MIN_AUTO_PUBLISH_SCORE || '65',
            required: true,
            validator: (v) => (/^\d+$/.test(v) && Number(v) >= 0 && Number(v) <= 100 ? true : 'Use an integer between 0 and 100.'),
        });
        const timezone = await promptInput(rl, 'TZ', {
            defaultValue: current.TZ || process.env.TZ || 'UTC',
            required: true,
        });
        const logLevel = await promptInput(rl, 'LOG_LEVEL (error/warn/info/debug)', {
            defaultValue: (current.LOG_LEVEL || 'info').toLowerCase(),
            required: true,
            validator: (v) => (['error', 'warn', 'info', 'debug'].includes(v) ? true : 'Use error, warn, info, or debug.'),
        });
        const nodeEnv = await promptInput(rl, 'NODE_ENV (development/production)', {
            defaultValue: (current.NODE_ENV || 'production').toLowerCase(),
            required: true,
            validator: (v) => (['development', 'production'].includes(v) ? true : 'Use development or production.'),
        });

        const allValues = {
            TELEGRAM_BOT_TOKEN: telegramToken,
            TELEGRAM_ALLOWED_USER_ID: telegramAllowedUserId,
            LLM_PROVIDER: provider,
            OPENAI_API_KEY: current.OPENAI_API_KEY || '',
            OPENAI_MODEL: current.OPENAI_MODEL || PROVIDER_MODELS.openai,
            ANTHROPIC_API_KEY: current.ANTHROPIC_API_KEY || '',
            ANTHROPIC_MODEL: current.ANTHROPIC_MODEL || PROVIDER_MODELS.anthropic,
            DEEPSEEK_API_KEY: current.DEEPSEEK_API_KEY || '',
            DEEPSEEK_MODEL: current.DEEPSEEK_MODEL || PROVIDER_MODELS.deepseek,
            TWITTER_API_KEY: twitterApiKey,
            TWITTER_API_SECRET: twitterApiSecret,
            TWITTER_ACCESS_TOKEN: twitterAccessToken,
            TWITTER_ACCESS_SECRET: twitterAccessSecret,
            DEFAULT_LANGUAGE: language.toLowerCase(),
            MAX_DAILY_POSTS: maxDailyPosts,
            PROMPT_TEMPLATE_VERSION: promptTemplateVersion.toLowerCase(),
            QUALITY_MIN_AUTO_PUBLISH_SCORE: qualityMinAutoPublishScore,
            LOG_LEVEL: logLevel,
            TZ: timezone,
            NODE_ENV: nodeEnv,
        };

        allValues[providerKeyField] = providerKey;
        allValues[modelField] = model;

        const output = buildEnvFileContent(allValues);
        fs.writeFileSync(envPath, output, { mode: 0o600 });

        loadEnv({ override: true });
        reloadConfig({ override: true });

        console.log('\nSetup completed.');
        console.log(`Config saved to: ${envPath}`);
        console.log(`Runtime home : ${runtimeHome}`);
        console.log('Next steps:');
        console.log('  1) nichebot doctor');
        console.log('  2) nichebot start\n');
    } finally {
        rl.close();
    }
}

function buildDoctorReport() {
    ensureRuntimeDirs();
    loadEnv({ override: true });
    reloadConfig({ override: true });
    const validation = validateConfig();
    const legacy = findLegacyPaths();
    const backups = listBackups();
    const dbInspection = inspectDatabase();
    const latestBackup = backups[0] || null;
    const latestBackupVerification = latestBackup
        ? (() => {
            try {
                return verifyBackup(latestBackup.id);
            } catch (error) {
                return { valid: false, issues: [error.message], warnings: [] };
            }
        })()
        : null;

    return {
        runtime: {
            home: runtimeHome,
            envPath,
            envExists: fs.existsSync(envPath),
            dataDir,
            dbPath,
            dbExists: fs.existsSync(dbPath),
            dbIntegrity: dbInspection.exists ? dbInspection.integrity : 'missing',
            dbHealthy: dbInspection.exists ? dbInspection.healthy : false,
            logsDir,
            lock: getLockStatus(),
            backups: {
                dir: backupsDir,
                count: backups.length,
                latest: latestBackup,
                latestIntegrity: latestBackupVerification
                    ? {
                        valid: latestBackupVerification.valid,
                        issues: latestBackupVerification.issues,
                    }
                    : null,
            },
        },
        config: {
            provider: config.llm.provider,
            language: config.defaultLanguage,
            promptTemplateVersion: config.prompt.templateVersion,
            qualityMinAutoPublishScore: config.quality.minAutoPublishScore,
            validation,
        },
        legacy: {
            packageRoot: legacy.packageRoot,
            legacyEnvPath: legacy.legacyEnvPath,
            legacyDbPath: legacy.legacyDbPath,
            hasLegacyEnv: legacy.hasLegacyEnv,
            hasLegacyDb: legacy.hasLegacyDb,
        },
    };
}

function printDoctorReport(report) {
    printHeader();
    console.log('Doctor report\n');
    console.log(`Runtime home: ${report.runtime.home}`);
    console.log(`Config file : ${report.runtime.envPath} (${report.runtime.envExists ? 'found' : 'missing'})`);
    console.log(`Database    : ${report.runtime.dbPath} (${report.runtime.dbExists ? 'found' : 'missing'})`);
    console.log(`DB integrity: ${report.runtime.dbIntegrity} (${report.runtime.dbHealthy ? 'healthy' : 'unhealthy'})`);
    console.log(`Logs dir    : ${report.runtime.logsDir}`);
    console.log(
        `Lock file   : ${report.runtime.lock.path} (${report.runtime.lock.active
            ? `active pid=${report.runtime.lock.pid}`
            : report.runtime.lock.exists
                ? 'stale'
                : 'missing'})`
    );
    console.log(`Backups     : ${report.runtime.backups.dir} (${report.runtime.backups.count})`);
    if (report.runtime.backups.latest) {
        console.log(`Latest bak  : ${report.runtime.backups.latest.id}`);
        const integrity = report.runtime.backups.latestIntegrity;
        if (integrity) {
            console.log(`Backup chk  : ${integrity.valid ? 'valid' : 'invalid'}`);
        }
    }
    console.log(`Provider    : ${report.config.provider}`);
    console.log(`Language    : ${report.config.language}`);
    console.log(`Template    : ${report.config.promptTemplateVersion}`);
    console.log(`Auto-Quality: ${report.config.qualityMinAutoPublishScore}`);
    console.log('');
    console.log(formatValidationReport(report.config.validation));
    console.log('');
}

function canPromptUser() {
    return Boolean(stdin.isTTY && stdout.isTTY);
}

async function runStart(options = {}) {
    const { allowSetupFallback = true } = options;

    ensureRuntimeDirs();
    migrateLegacyIfNeeded();

    if (!fs.existsSync(envPath)) {
        loadEnv({ override: true });
        reloadConfig({ override: true });
        const runtimeEnvValidation = validateConfig();

        if (!runtimeEnvValidation.valid) {
            if (allowSetupFallback && canPromptUser()) {
                console.log('No runtime .env found. Launching setup wizard...\n');
                await runSetupWizard();
            } else {
                console.error(`Missing runtime config: ${envPath}`);
                console.error('Run: nichebot setup');
                process.exitCode = 1;
                return;
            }
        } else {
            console.log('Runtime .env not found; using environment variables from current process.');
        }
    }

    loadEnv({ override: true });
    reloadConfig({ override: true });
    const validation = validateConfig();
    if (!validation.valid) {
        console.error(formatValidationReport(validation));
        console.error('\nRun "nichebot setup" to fix configuration errors.');
        process.exitCode = 1;
        return;
    }

    require('./index');
}

function printBackupList(backups) {
    if (!Array.isArray(backups) || backups.length === 0) {
        console.log('No backups found.');
        return;
    }

    console.log(`Found ${backups.length} backup(s):`);
    backups.forEach((backup, index) => {
        const createdAt = backup.createdAt || 'unknown-time';
        const reason = backup.reason || 'unknown-reason';
        const bytes = Number(backup.totalBytes || 0);
        const files = Number(backup.fileCount || 0);
        console.log(`${index + 1}. ${backup.id} (${createdAt}) reason=${reason} files=${files} bytes=${bytes}`);
    });
}

function getOptionValue(args, optionName) {
    const index = args.indexOf(optionName);
    if (index === -1) return null;
    const next = args[index + 1];
    if (!next || next.startsWith('--')) return null;
    return next;
}

function hasFlag(args, flag) {
    return Array.isArray(args) && args.includes(flag);
}

function printBootstrapResult(result) {
    printHeader();
    console.log('Bootstrap report\n');
    result.steps.forEach((step, index) => {
        const mark = step.status === 'ok'
            ? 'OK'
            : step.status === 'skipped'
                ? 'SKIP'
                : 'FAIL';
        console.log(`${index + 1}. [${mark}] ${step.name} - ${step.message}`);
    });

    if (Array.isArray(result.warnings) && result.warnings.length > 0) {
        console.log('\nSecurity reminders:');
        result.warnings.forEach((line, idx) => {
            console.log(`  ${idx + 1}. ${line}`);
        });
    }

    console.log(`\nResult: ${result.ok ? 'ready' : 'needs-fix'}`);
    console.log(`Next: ${result.recommendation}`);
    console.log('');
}

function printServiceStatus(status) {
    console.log(`Platform   : ${status.platform}`);
    console.log(`Installed  : ${status.installed ? 'yes' : 'no'}`);
    console.log(`Running    : ${status.running ? 'yes' : 'no'}`);
    if (typeof status.enabled === 'boolean') {
        console.log(`Enabled    : ${status.enabled ? 'yes' : 'no'}`);
    }
    if (status.servicePath) {
        console.log(`Service    : ${status.servicePath}`);
    }
    if (status.plistPath) {
        console.log(`Agent      : ${status.plistPath}`);
    }
    if (status.taskName) {
        console.log(`Task       : ${status.taskName}`);
    }
    if (status.detail) {
        const preview = String(status.detail).trim();
        if (preview) {
            console.log('\nDetails:');
            console.log(preview);
        }
    }
    if (status.error) {
        console.log(`\nError      : ${status.error}`);
    }
}

function printServiceLogs(logs) {
    const standardPath = logs.standard?.path || '-';
    const errorPath = logs.errors?.path || '-';
    console.log(`Source      : ${logs.source}`);
    console.log(`Standard log: ${standardPath}`);
    if (logs.standard?.exists) {
        console.log('\n--- nichebot.log ---');
        console.log(logs.standard.lines.join('\n') || '(empty)');
    } else {
        console.log('\n--- nichebot.log ---');
        console.log('Log file not found.');
    }

    console.log(`\nError log   : ${errorPath}`);
    if (logs.errors?.exists) {
        console.log('--- error.log ---');
        console.log(logs.errors.lines.join('\n') || '(empty)');
    } else {
        console.log('--- error.log ---');
        console.log('Error log not found.');
    }
}

function printServiceDoctor(report) {
    printServiceStatus(report.service);
    console.log('\nSecurity checks:');
    console.log(`  env permissions  : ${report.security.checks.envPermissionsOk ? 'ok' : 'issue'}`);
    console.log(`  allowed user id  : ${report.security.checks.allowedUserConfigured ? 'ok' : 'issue'}`);
    console.log(`  observability    : ${report.security.checks.observabilitySafe ? 'ok' : 'issue'}`);
    if (report.security.issues.length > 0) {
        console.log('\nSecurity issues:');
        report.security.issues.forEach((issue, idx) => {
            console.log(`  ${idx + 1}. ${issue.code}: ${issue.message}`);
        });
    }
}

async function waitForLockRelease(timeoutMs = 10000) {
    const waitUntil = Date.now() + timeoutMs;
    while (Date.now() < waitUntil) {
        const lock = getLockStatus();
        if (!lock.active) {
            return true;
        }
        await new Promise((resolve) => setTimeout(resolve, 250));
    }
    return false;
}

async function main() {
    const command = String(process.argv[2] || 'start').toLowerCase();
    const args = process.argv.slice(3);

    if (['help', '--help', '-h'].includes(command)) {
        printHelp();
        return;
    }

    if (command === 'bootstrap') {
        const asJson = hasFlag(args, '--json') || process.argv.includes('--json');
        const result = await runBootstrap({
            nonInteractive: hasFlag(args, '--non-interactive'),
            skipInstall: hasFlag(args, '--skip-install'),
            skipSetup: hasFlag(args, '--skip-setup'),
            skipDoctor: hasFlag(args, '--skip-doctor'),
            runSetupWizard,
            canPromptUser,
            runDoctorReport: buildDoctorReport,
            cwd: path.resolve(__dirname, '..'),
            env: process.env,
        });

        if (asJson) {
            console.log(JSON.stringify(result, null, 2));
        } else {
            printBootstrapResult(result);
        }
        process.exitCode = result.ok ? 0 : 1;
        return;
    }

    if (command === 'setup') {
        await runSetupWizard();
        return;
    }

    if (command === 'doctor') {
        const report = buildDoctorReport();
        const asJson = args.includes('--json') || process.argv.includes('--json');
        if (asJson) {
            console.log(JSON.stringify(report, null, 2));
        } else {
            printDoctorReport(report);
        }
        process.exitCode = report.config.validation.valid ? 0 : 1;
        return;
    }

    if (command === 'start') {
        await runStart({ allowSetupFallback: true });
        return;
    }

    if (command === 'stop') {
        const status = getLockStatus();
        if (!status.exists) {
            console.log('No running lock found.');
            return;
        }
        if (!status.active || !status.pid) {
            console.log('Lock file exists but process is not active (stale lock).');
            return;
        }
        if (status.pid === process.pid) {
            console.log('Current CLI process owns the lock; nothing to stop.');
            return;
        }

        try {
            process.kill(status.pid, 'SIGTERM');
        } catch (error) {
            console.error(`Failed to send SIGTERM to pid ${status.pid}: ${error.message}`);
            process.exitCode = 1;
            return;
        }

        const waitUntil = Date.now() + 10000;
        while (Date.now() < waitUntil) {
            if (!isPidRunning(status.pid)) {
                console.log(`Stopped process ${status.pid}.`);
                return;
            }
            await new Promise((resolve) => setTimeout(resolve, 200));
        }

        console.error(`Process ${status.pid} did not stop within timeout.`);
        process.exitCode = 1;
        return;
    }

    if (command === 'service') {
        const asJson = hasFlag(args, '--json');
        const platformOverride = getOptionValue(args, '--platform');
        const lineCount = Number.parseInt(getOptionValue(args, '--lines') || '200', 10);
        const serviceOptions = {
            platform: platformOverride || process.platform,
        };
        const subcommand = args[0] && !args[0].startsWith('--')
            ? String(args[0]).toLowerCase()
            : 'status';

        try {
            if (subcommand === 'install') {
                const result = installService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log(`Service installed for platform: ${detectServicePlatform(serviceOptions.platform)}`);
                    printServiceStatus(statusService(serviceOptions));
                }
                return;
            }

            if (subcommand === 'uninstall') {
                const result = uninstallService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log(`Service uninstalled for platform: ${detectServicePlatform(serviceOptions.platform)}`);
                }
                return;
            }

            if (subcommand === 'start') {
                const lock = getLockStatus();
                if (lock.active) {
                    console.error(`Runtime lock is already active (pid=${lock.pid}). Stop running process before service start.`);
                    process.exitCode = 1;
                    return;
                }

                const result = startService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log('Service start requested.');
                    printServiceStatus(statusService(serviceOptions));
                }
                return;
            }

            if (subcommand === 'stop') {
                const result = stopService(serviceOptions);
                const released = await waitForLockRelease(12000);
                if (asJson) {
                    console.log(JSON.stringify({ ...result, lockReleased: released }, null, 2));
                } else {
                    console.log('Service stop requested.');
                    if (!released) {
                        console.warn('Lock is still active after timeout. Inspect service logs/status.');
                    }
                    printServiceStatus(statusService(serviceOptions));
                }
                process.exitCode = released ? 0 : 1;
                return;
            }

            if (subcommand === 'restart') {
                const result = restartService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log('Service restart requested.');
                    printServiceStatus(statusService(serviceOptions));
                }
                return;
            }

            if (subcommand === 'status') {
                const status = statusService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(status, null, 2));
                } else {
                    printServiceStatus(status);
                }
                process.exitCode = status.running ? 0 : 1;
                return;
            }

            if (subcommand === 'logs') {
                const logs = logsService({ ...serviceOptions, lines: lineCount });
                if (asJson) {
                    console.log(JSON.stringify(logs, null, 2));
                } else {
                    printServiceLogs(logs);
                }
                return;
            }

            if (subcommand === 'doctor') {
                const report = doctorService(serviceOptions);
                if (asJson) {
                    console.log(JSON.stringify(report, null, 2));
                } else {
                    printServiceDoctor(report);
                }
                process.exitCode = report.validation.valid ? 0 : 1;
                return;
            }
        } catch (error) {
            console.error(`Service command failed: ${error.message}`);
            process.exitCode = 1;
            return;
        }

        console.error(`Unknown service command: ${subcommand}`);
        console.error('Usage: nichebot service install|uninstall|start|stop|restart|status|logs|doctor [--json] [--platform <linux|darwin|win32>] [--lines 200]');
        process.exitCode = 1;
        return;
    }

    if (command === 'backup') {
        const asJson = args.includes('--json');
        const subcommand = args[0] && !args[0].startsWith('--')
            ? String(args[0]).toLowerCase()
            : null;

        if (subcommand === 'list') {
            const backups = listBackups();
            if (asJson) {
                console.log(JSON.stringify({ backups }, null, 2));
            } else {
                printBackupList(backups);
            }
            return;
        }

        if (subcommand === 'verify') {
            const explicitId = args.slice(1).find((value) => !value.startsWith('--'));
            const backupId = explicitId || (args.includes('--latest') ? getLatestBackup()?.id : null);
            if (!backupId) {
                console.error('No backup id provided. Usage: nichebot backup verify <id> or --latest');
                process.exitCode = 1;
                return;
            }

            const verification = verifyBackup(backupId);
            if (asJson) {
                console.log(JSON.stringify(verification, null, 2));
            } else {
                console.log(`Backup verify: ${verification.backupId}`);
                console.log(`Status: ${verification.valid ? 'valid' : 'invalid'}`);
                console.log(`Checked files: ${verification.checkedFiles}/${verification.manifestFileCount}`);
                if (verification.issues.length > 0) {
                    verification.issues.forEach((issue, index) => {
                        console.log(`Issue ${index + 1}: ${issue}`);
                    });
                }
            }
            process.exitCode = verification.valid ? 0 : 1;
            return;
        }

        if (subcommand === 'prune') {
            const keepValue = getOptionValue(args, '--keep');
            const keep = keepValue !== null ? Number.parseInt(keepValue, 10) : 10;
            if (!Number.isInteger(keep) || keep < 0) {
                console.error('Invalid --keep value. Use a non-negative integer.');
                process.exitCode = 1;
                return;
            }

            const result = pruneBackups({ keep });
            if (asJson) {
                console.log(JSON.stringify(result, null, 2));
            } else {
                console.log(`Pruned backups: removed=${result.removed.length}, remaining=${result.remaining}, keep=${result.keep}`);
                if (result.removed.length > 0) {
                    console.log(`Removed ids: ${result.removed.join(', ')}`);
                }
            }
            return;
        }

        const created = createRuntimeBackup({ reason: 'manual_cli' });
        if (asJson) {
            console.log(JSON.stringify(created, null, 2));
        } else {
            console.log(`Backup created: ${created.id}`);
            console.log(`Path: ${created.backupDir}`);
            console.log(`Files: ${created.files.map((f) => f.path).join(', ') || '-'}`);
        }
        return;
    }

    if (command === 'restore') {
        const asJson = args.includes('--json');
        const target = args.find((value) => !value.startsWith('--'));
        const lock = getLockStatus();

        if (lock.active) {
            console.error(
                `Cannot restore while bot is running (pid=${lock.pid}). Stop it first: nichebot stop`
            );
            process.exitCode = 1;
            return;
        }

        let backupId = target;
        if (!backupId || backupId === '--latest') {
            backupId = getLatestBackup()?.id || null;
        }

        if (!backupId) {
            console.error('No backup id provided and no backup found.');
            console.error('Usage: nichebot restore <backup-id>');
            process.exitCode = 1;
            return;
        }

        const restored = restoreRuntimeBackup(backupId, { createSafetyBackup: true });
        if (asJson) {
            console.log(JSON.stringify(restored, null, 2));
        } else {
            console.log(`Restore completed from backup: ${restored.backupId}`);
            console.log(`Restored paths: ${restored.restored.join(', ') || '-'}`);
            if (restored.preRestoreBackup) {
                console.log(`Safety backup created: ${restored.preRestoreBackup.id}`);
            }
        }
        return;
    }

    if (command === 'db') {
        const asJson = args.includes('--json');
        const subcommand = args[0] && !args[0].startsWith('--')
            ? String(args[0]).toLowerCase()
            : 'doctor';

        if (subcommand === 'doctor') {
            const report = inspectDatabase();
            if (asJson) {
                console.log(JSON.stringify(report, null, 2));
            } else {
                if (!report.exists) {
                    console.log(`Database not found: ${report.path}`);
                } else {
                    console.log(`DB path      : ${report.path}`);
                    console.log(`Integrity    : ${report.integrity}`);
                    console.log(`Healthy      : ${report.healthy ? 'yes' : 'no'}`);
                    console.log(`Journal mode : ${report.journalMode}`);
                    console.log(`File bytes   : ${report.fileBytes}`);
                    console.log(`Used bytes   : ${report.estimatedUsedBytes}`);
                    console.log(`Page count   : ${report.pageCount}`);
                    console.log(`Free pages   : ${report.freePages}`);
                    console.log(`Tables       : niches=${report.tables.niches ?? '-'}, posts=${report.tables.posts ?? '-'}, schedules=${report.tables.schedules ?? '-'}, settings=${report.tables.settings ?? '-'}`);
                }
            }
            process.exitCode = report.healthy ? 0 : 1;
            return;
        }

        if (subcommand === 'optimize') {
            const lock = getLockStatus();
            if (lock.active) {
                console.error(
                    `Cannot optimize while bot is running (pid=${lock.pid}). Stop it first: nichebot stop`
                );
                process.exitCode = 1;
                return;
            }

            try {
                const result = optimizeDatabase();
                if (asJson) {
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log(`Optimized DB : ${result.path}`);
                    console.log(`Bytes reduced: ${result.bytesReduced}`);
                    console.log(`Free pages   : ${result.before.freePages} -> ${result.after.freePages}`);
                    console.log(`Integrity    : ${result.after.integrity}`);
                }
            } catch (error) {
                console.error(`DB optimize failed: ${error.message}`);
                process.exitCode = 1;
                return;
            }
            return;
        }

        console.error(`Unknown db command: ${subcommand}`);
        console.error('Usage: nichebot db doctor|optimize [--json]');
        process.exitCode = 1;
        return;
    }

    console.error(`Unknown command: ${command}`);
    printHelp();
    process.exitCode = 1;
}

main().catch((error) => {
    console.error('CLI failed:', error?.message || error);
    process.exit(1);
});
