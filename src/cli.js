#!/usr/bin/env node

/**
 * NicheBot CLI
 * Commands:
 *   nichebot setup
 *   nichebot doctor [--json]
 *   nichebot start
 *   nichebot stop
 *   nichebot backup
 *   nichebot restore <id|--latest>
 *   nichebot (defaults to start)
 */

const fs = require('fs');
const path = require('path');
const readline = require('node:readline/promises');
const { stdin, stdout } = require('node:process');
const dotenv = require('dotenv');

const {
    runtimeHome,
    envPath,
    dataDir,
    dbPath,
    logsDir,
    backupsDir,
    ensureRuntimeDirs,
    findLegacyPaths,
} = require('./runtime/paths');
const { getLockStatus, isPidRunning } = require('./runtime/lock');
const {
    listBackups,
    getLatestBackup,
    createRuntimeBackup,
    restoreRuntimeBackup,
} = require('./runtime/backup');
const {
    config,
    loadEnv,
    reloadConfig,
    validateConfig,
    formatValidationReport,
} = require('./config');

const PROVIDER_MODELS = {
    openai: 'gpt-4o-mini',
    anthropic: 'claude-sonnet-4-20250514',
    deepseek: 'deepseek-chat',
};

function nowStamp() {
    return new Date().toISOString().replace(/[:.]/g, '-');
}

function pathEquals(a, b) {
    return path.resolve(a) === path.resolve(b);
}

function parseEnvFile(filePath) {
    if (!fs.existsSync(filePath)) return {};
    try {
        const raw = fs.readFileSync(filePath, 'utf8');
        return dotenv.parse(raw);
    } catch {
        return {};
    }
}

function quoteEnvValue(value) {
    const stringValue = String(value ?? '');
    if (stringValue === '') return '';
    if (/[\s#"'`]/.test(stringValue)) {
        return JSON.stringify(stringValue);
    }
    return stringValue;
}

function buildEnvFileContent(values) {
    const lines = [
        '# ===================================',
        '# NicheBot Runtime Configuration',
        '# Generated by: nichebot setup',
        '# Runtime home: ~/.nichebot (or $NICHEBOT_HOME)',
        '# ===================================',
        '',
        '# --- TELEGRAM (REQUIRED) ---',
        '# Get your bot token from @BotFather',
        `TELEGRAM_BOT_TOKEN=${quoteEnvValue(values.TELEGRAM_BOT_TOKEN)}`,
        '# Your Telegram user ID (required in strict single-user mode)',
        `TELEGRAM_ALLOWED_USER_ID=${quoteEnvValue(values.TELEGRAM_ALLOWED_USER_ID)}`,
        '',
        '# --- LLM PROVIDER (REQUIRED) ---',
        '# Options: openai, anthropic, deepseek',
        `LLM_PROVIDER=${quoteEnvValue(values.LLM_PROVIDER)}`,
        '',
        '# OpenAI',
        `OPENAI_API_KEY=${quoteEnvValue(values.OPENAI_API_KEY)}`,
        `OPENAI_MODEL=${quoteEnvValue(values.OPENAI_MODEL)}`,
        '',
        '# Anthropic Claude',
        `ANTHROPIC_API_KEY=${quoteEnvValue(values.ANTHROPIC_API_KEY)}`,
        `ANTHROPIC_MODEL=${quoteEnvValue(values.ANTHROPIC_MODEL)}`,
        '',
        '# DeepSeek',
        `DEEPSEEK_API_KEY=${quoteEnvValue(values.DEEPSEEK_API_KEY)}`,
        `DEEPSEEK_MODEL=${quoteEnvValue(values.DEEPSEEK_MODEL)}`,
        '',
        '# --- TWITTER/X (OPTIONAL) ---',
        `TWITTER_API_KEY=${quoteEnvValue(values.TWITTER_API_KEY)}`,
        `TWITTER_API_SECRET=${quoteEnvValue(values.TWITTER_API_SECRET)}`,
        `TWITTER_ACCESS_TOKEN=${quoteEnvValue(values.TWITTER_ACCESS_TOKEN)}`,
        `TWITTER_ACCESS_SECRET=${quoteEnvValue(values.TWITTER_ACCESS_SECRET)}`,
        '',
        '# --- GENERAL SETTINGS ---',
        `DEFAULT_LANGUAGE=${quoteEnvValue(values.DEFAULT_LANGUAGE)}`,
        `MAX_DAILY_POSTS=${quoteEnvValue(values.MAX_DAILY_POSTS)}`,
        '',
        '# --- PROMPT & QUALITY ---',
        '# Supported prompt template versions: v1',
        `PROMPT_TEMPLATE_VERSION=${quoteEnvValue(values.PROMPT_TEMPLATE_VERSION)}`,
        '# Auto scheduler publish threshold (0-100)',
        `QUALITY_MIN_AUTO_PUBLISH_SCORE=${quoteEnvValue(values.QUALITY_MIN_AUTO_PUBLISH_SCORE)}`,
        '',
        '# --- RUNTIME ---',
        `LOG_LEVEL=${quoteEnvValue(values.LOG_LEVEL)}`,
        `TZ=${quoteEnvValue(values.TZ)}`,
        `NODE_ENV=${quoteEnvValue(values.NODE_ENV)}`,
        '',
    ];

    return `${lines.join('\n')}\n`;
}

function printHeader() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         ü§ñ NicheBot CLI             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);
}

function printHelp() {
    printHeader();
    console.log('Usage: nichebot <command>\n');
    console.log('Commands:');
    console.log('  setup           Interactive setup wizard');
    console.log('  doctor [--json] Check runtime/config status without starting the bot');
    console.log('  start           Validate config and start bot runtime');
    console.log('  stop            Stop running bot process (if lock is active)');
    console.log('  backup          Create runtime backup');
    console.log('  backup list     List available backups');
    console.log('  restore <id>    Restore runtime backup');
    console.log('  help            Show this help');
    console.log('');
    console.log('Runtime paths:');
    console.log(`  home: ${runtimeHome}`);
    console.log(`  env:  ${envPath}`);
    console.log(`  db:   ${dbPath}`);
    console.log(`  lock: ${getLockStatus().path}`);
    console.log(`  bak:  ${backupsDir}`);
    console.log('');
}

function backupFile(filePath) {
    if (!fs.existsSync(filePath)) return null;
    const backupPath = `${filePath}.backup-${nowStamp()}`;
    fs.copyFileSync(filePath, backupPath);
    return backupPath;
}

function migrateLegacyIfNeeded() {
    ensureRuntimeDirs();
    const legacy = findLegacyPaths();
    const report = {
        migrated: false,
        env: null,
        db: null,
    };

    const shouldMigrateFromLegacy = !fs.existsSync(envPath) && legacy.hasLegacyEnv;
    if (!shouldMigrateFromLegacy) {
        return report;
    }

    const canMigrateEnv =
        shouldMigrateFromLegacy &&
        !pathEquals(legacy.legacyEnvPath, envPath);

    if (canMigrateEnv) {
        const backupPath = backupFile(legacy.legacyEnvPath);
        fs.copyFileSync(legacy.legacyEnvPath, envPath);
        report.migrated = true;
        report.env = {
            from: legacy.legacyEnvPath,
            to: envPath,
            backup: backupPath,
        };
    }

    const canMigrateDb =
        shouldMigrateFromLegacy &&
        legacy.hasLegacyDb &&
        !fs.existsSync(dbPath) &&
        !pathEquals(legacy.legacyDbPath, dbPath);

    if (canMigrateDb) {
        if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
        const backupPath = backupFile(legacy.legacyDbPath);
        fs.copyFileSync(legacy.legacyDbPath, dbPath);
        report.migrated = true;
        report.db = {
            from: legacy.legacyDbPath,
            to: dbPath,
            backup: backupPath,
        };
    }

    if (report.migrated) {
        console.log('Migration report:');
        if (report.env) {
            console.log(`- .env migrated: ${report.env.from} -> ${report.env.to}`);
            if (report.env.backup) console.log(`  backup: ${report.env.backup}`);
        }
        if (report.db) {
            console.log(`- DB migrated: ${report.db.from} -> ${report.db.to}`);
            if (report.db.backup) console.log(`  backup: ${report.db.backup}`);
        }
        console.log('');
    }

    return report;
}

async function promptInput(rl, prompt, options = {}) {
    const { defaultValue = '', required = false, validator = null, mask = false } = options;

    while (true) {
        const suffix = defaultValue ? ` [${defaultValue}]` : '';
        const raw = await rl.question(`${prompt}${suffix}: `);
        const value = (raw || defaultValue || '').trim();

        if (required && !value) {
            console.log('This field is required.');
            continue;
        }

        if (validator) {
            const validation = validator(value);
            if (validation !== true) {
                console.log(validation || 'Invalid value.');
                continue;
            }
        }

        if (mask && value) {
            return value;
        }
        return value;
    }
}

function validateProvider(value) {
    const normalized = String(value || '').trim().toLowerCase();
    return ['openai', 'anthropic', 'deepseek'].includes(normalized);
}

function getProviderKeyField(provider) {
    if (provider === 'openai') return 'OPENAI_API_KEY';
    if (provider === 'anthropic') return 'ANTHROPIC_API_KEY';
    return 'DEEPSEEK_API_KEY';
}

async function runSetupWizard() {
    if (!canPromptUser()) {
        console.error('Setup wizard requires an interactive terminal (TTY).');
        process.exitCode = 1;
        return;
    }

    ensureRuntimeDirs();
    const current = parseEnvFile(envPath);

    printHeader();
    console.log('Interactive setup wizard');
    console.log(`Runtime home: ${runtimeHome}`);
    console.log(`Config file : ${envPath}`);
    console.log('');

    const rl = readline.createInterface({ input: stdin, output: stdout });

    try {
        const language = await promptInput(rl, 'Default language (tr/en)', {
            defaultValue: (current.DEFAULT_LANGUAGE || '').toLowerCase() || 'en',
            required: true,
            validator: (v) => (['tr', 'en'].includes(v.toLowerCase()) ? true : 'Use "tr" or "en".'),
        });

        const telegramToken = await promptInput(rl, 'Telegram bot token', {
            defaultValue: current.TELEGRAM_BOT_TOKEN || '',
            required: true,
        });

        const telegramAllowedUserId = await promptInput(rl, 'Telegram allowed user id', {
            defaultValue: current.TELEGRAM_ALLOWED_USER_ID || '',
            required: true,
            validator: (v) => (/^\d+$/.test(v) ? true : 'Use a numeric Telegram user id.'),
        });

        const provider = (await promptInput(rl, 'LLM provider (openai/anthropic/deepseek)', {
            defaultValue: (current.LLM_PROVIDER || 'deepseek').toLowerCase(),
            required: true,
            validator: (v) => (validateProvider(v) ? true : 'Use one of: openai, anthropic, deepseek.'),
        })).toLowerCase();

        const providerKeyField = getProviderKeyField(provider);
        const providerKey = await promptInput(rl, `${providerKeyField}`, {
            defaultValue: current[providerKeyField] || '',
            required: true,
            mask: true,
        });

        const modelField = `${provider.toUpperCase()}_MODEL`;
        const model = await promptInput(rl, `${modelField}`, {
            defaultValue: current[modelField] || PROVIDER_MODELS[provider],
            required: true,
        });

        console.log('\nTwitter setup is optional. Leave blank to skip.');
        const twitterApiKey = await promptInput(rl, 'TWITTER_API_KEY', { defaultValue: current.TWITTER_API_KEY || '' });
        const twitterApiSecret = await promptInput(rl, 'TWITTER_API_SECRET', { defaultValue: current.TWITTER_API_SECRET || '' });
        const twitterAccessToken = await promptInput(rl, 'TWITTER_ACCESS_TOKEN', { defaultValue: current.TWITTER_ACCESS_TOKEN || '' });
        const twitterAccessSecret = await promptInput(rl, 'TWITTER_ACCESS_SECRET', { defaultValue: current.TWITTER_ACCESS_SECRET || '' });

        const maxDailyPosts = await promptInput(rl, 'MAX_DAILY_POSTS', {
            defaultValue: current.MAX_DAILY_POSTS || '5',
            required: true,
            validator: (v) => (/^\d+$/.test(v) && Number(v) > 0 ? true : 'Use a positive integer.'),
        });
        const promptTemplateVersion = await promptInput(rl, 'PROMPT_TEMPLATE_VERSION (v1)', {
            defaultValue: (current.PROMPT_TEMPLATE_VERSION || 'v1').toLowerCase(),
            required: true,
            validator: (v) => (/^v\d+$/.test(v.toLowerCase()) ? true : 'Use format like v1.'),
        });
        const qualityMinAutoPublishScore = await promptInput(rl, 'QUALITY_MIN_AUTO_PUBLISH_SCORE (0-100)', {
            defaultValue: current.QUALITY_MIN_AUTO_PUBLISH_SCORE || '65',
            required: true,
            validator: (v) => (/^\d+$/.test(v) && Number(v) >= 0 && Number(v) <= 100 ? true : 'Use an integer between 0 and 100.'),
        });
        const timezone = await promptInput(rl, 'TZ', {
            defaultValue: current.TZ || process.env.TZ || 'UTC',
            required: true,
        });
        const logLevel = await promptInput(rl, 'LOG_LEVEL (error/warn/info/debug)', {
            defaultValue: (current.LOG_LEVEL || 'info').toLowerCase(),
            required: true,
            validator: (v) => (['error', 'warn', 'info', 'debug'].includes(v) ? true : 'Use error, warn, info, or debug.'),
        });
        const nodeEnv = await promptInput(rl, 'NODE_ENV (development/production)', {
            defaultValue: (current.NODE_ENV || 'production').toLowerCase(),
            required: true,
            validator: (v) => (['development', 'production'].includes(v) ? true : 'Use development or production.'),
        });

        const allValues = {
            TELEGRAM_BOT_TOKEN: telegramToken,
            TELEGRAM_ALLOWED_USER_ID: telegramAllowedUserId,
            LLM_PROVIDER: provider,
            OPENAI_API_KEY: current.OPENAI_API_KEY || '',
            OPENAI_MODEL: current.OPENAI_MODEL || PROVIDER_MODELS.openai,
            ANTHROPIC_API_KEY: current.ANTHROPIC_API_KEY || '',
            ANTHROPIC_MODEL: current.ANTHROPIC_MODEL || PROVIDER_MODELS.anthropic,
            DEEPSEEK_API_KEY: current.DEEPSEEK_API_KEY || '',
            DEEPSEEK_MODEL: current.DEEPSEEK_MODEL || PROVIDER_MODELS.deepseek,
            TWITTER_API_KEY: twitterApiKey,
            TWITTER_API_SECRET: twitterApiSecret,
            TWITTER_ACCESS_TOKEN: twitterAccessToken,
            TWITTER_ACCESS_SECRET: twitterAccessSecret,
            DEFAULT_LANGUAGE: language.toLowerCase(),
            MAX_DAILY_POSTS: maxDailyPosts,
            PROMPT_TEMPLATE_VERSION: promptTemplateVersion.toLowerCase(),
            QUALITY_MIN_AUTO_PUBLISH_SCORE: qualityMinAutoPublishScore,
            LOG_LEVEL: logLevel,
            TZ: timezone,
            NODE_ENV: nodeEnv,
        };

        allValues[providerKeyField] = providerKey;
        allValues[modelField] = model;

        const output = buildEnvFileContent(allValues);
        fs.writeFileSync(envPath, output, { mode: 0o600 });

        loadEnv({ override: true });
        reloadConfig({ override: true });

        console.log('\nSetup completed.');
        console.log(`Config saved to: ${envPath}`);
        console.log(`Runtime home : ${runtimeHome}`);
        console.log('Next steps:');
        console.log('  1) nichebot doctor');
        console.log('  2) nichebot start\n');
    } finally {
        rl.close();
    }
}

function buildDoctorReport() {
    ensureRuntimeDirs();
    loadEnv({ override: true });
    reloadConfig({ override: true });
    const validation = validateConfig();
    const legacy = findLegacyPaths();
    const backups = listBackups();

    return {
        runtime: {
            home: runtimeHome,
            envPath,
            envExists: fs.existsSync(envPath),
            dataDir,
            dbPath,
            dbExists: fs.existsSync(dbPath),
            logsDir,
            lock: getLockStatus(),
            backups: {
                dir: backupsDir,
                count: backups.length,
                latest: backups[0] || null,
            },
        },
        config: {
            provider: config.llm.provider,
            language: config.defaultLanguage,
            promptTemplateVersion: config.prompt.templateVersion,
            qualityMinAutoPublishScore: config.quality.minAutoPublishScore,
            validation,
        },
        legacy: {
            packageRoot: legacy.packageRoot,
            legacyEnvPath: legacy.legacyEnvPath,
            legacyDbPath: legacy.legacyDbPath,
            hasLegacyEnv: legacy.hasLegacyEnv,
            hasLegacyDb: legacy.hasLegacyDb,
        },
    };
}

function printDoctorReport(report) {
    printHeader();
    console.log('Doctor report\n');
    console.log(`Runtime home: ${report.runtime.home}`);
    console.log(`Config file : ${report.runtime.envPath} (${report.runtime.envExists ? 'found' : 'missing'})`);
    console.log(`Database    : ${report.runtime.dbPath} (${report.runtime.dbExists ? 'found' : 'missing'})`);
    console.log(`Logs dir    : ${report.runtime.logsDir}`);
    console.log(
        `Lock file   : ${report.runtime.lock.path} (${report.runtime.lock.active
            ? `active pid=${report.runtime.lock.pid}`
            : report.runtime.lock.exists
                ? 'stale'
                : 'missing'})`
    );
    console.log(`Backups     : ${report.runtime.backups.dir} (${report.runtime.backups.count})`);
    console.log(`Provider    : ${report.config.provider}`);
    console.log(`Language    : ${report.config.language}`);
    console.log(`Template    : ${report.config.promptTemplateVersion}`);
    console.log(`Auto-Quality: ${report.config.qualityMinAutoPublishScore}`);
    console.log('');
    console.log(formatValidationReport(report.config.validation));
    console.log('');
}

function canPromptUser() {
    return Boolean(stdin.isTTY && stdout.isTTY);
}

async function runStart(options = {}) {
    const { allowSetupFallback = true } = options;

    ensureRuntimeDirs();
    migrateLegacyIfNeeded();

    if (!fs.existsSync(envPath)) {
        loadEnv({ override: true });
        reloadConfig({ override: true });
        const runtimeEnvValidation = validateConfig();

        if (!runtimeEnvValidation.valid) {
            if (allowSetupFallback && canPromptUser()) {
                console.log('No runtime .env found. Launching setup wizard...\n');
                await runSetupWizard();
            } else {
                console.error(`Missing runtime config: ${envPath}`);
                console.error('Run: nichebot setup');
                process.exitCode = 1;
                return;
            }
        } else {
            console.log('Runtime .env not found; using environment variables from current process.');
        }
    }

    loadEnv({ override: true });
    reloadConfig({ override: true });
    const validation = validateConfig();
    if (!validation.valid) {
        console.error(formatValidationReport(validation));
        console.error('\nRun "nichebot setup" to fix configuration errors.');
        process.exitCode = 1;
        return;
    }

    require('./index');
}

function printBackupList(backups) {
    if (!Array.isArray(backups) || backups.length === 0) {
        console.log('No backups found.');
        return;
    }

    console.log(`Found ${backups.length} backup(s):`);
    backups.forEach((backup, index) => {
        const createdAt = backup.createdAt || 'unknown-time';
        const reason = backup.reason || 'unknown-reason';
        console.log(`${index + 1}. ${backup.id} (${createdAt}) reason=${reason}`);
    });
}

async function main() {
    const command = String(process.argv[2] || 'start').toLowerCase();
    const args = process.argv.slice(3);

    if (['help', '--help', '-h'].includes(command)) {
        printHelp();
        return;
    }

    if (command === 'setup') {
        await runSetupWizard();
        return;
    }

    if (command === 'doctor') {
        const report = buildDoctorReport();
        const asJson = args.includes('--json') || process.argv.includes('--json');
        if (asJson) {
            console.log(JSON.stringify(report, null, 2));
        } else {
            printDoctorReport(report);
        }
        process.exitCode = report.config.validation.valid ? 0 : 1;
        return;
    }

    if (command === 'start') {
        await runStart({ allowSetupFallback: true });
        return;
    }

    if (command === 'stop') {
        const status = getLockStatus();
        if (!status.exists) {
            console.log('No running lock found.');
            return;
        }
        if (!status.active || !status.pid) {
            console.log('Lock file exists but process is not active (stale lock).');
            return;
        }
        if (status.pid === process.pid) {
            console.log('Current CLI process owns the lock; nothing to stop.');
            return;
        }

        try {
            process.kill(status.pid, 'SIGTERM');
        } catch (error) {
            console.error(`Failed to send SIGTERM to pid ${status.pid}: ${error.message}`);
            process.exitCode = 1;
            return;
        }

        const waitUntil = Date.now() + 10000;
        while (Date.now() < waitUntil) {
            if (!isPidRunning(status.pid)) {
                console.log(`Stopped process ${status.pid}.`);
                return;
            }
            await new Promise((resolve) => setTimeout(resolve, 200));
        }

        console.error(`Process ${status.pid} did not stop within timeout.`);
        process.exitCode = 1;
        return;
    }

    if (command === 'backup') {
        const asJson = args.includes('--json');
        if (args[0] === 'list') {
            const backups = listBackups();
            if (asJson) {
                console.log(JSON.stringify({ backups }, null, 2));
            } else {
                printBackupList(backups);
            }
            return;
        }

        const created = createRuntimeBackup({ reason: 'manual_cli' });
        if (asJson) {
            console.log(JSON.stringify(created, null, 2));
        } else {
            console.log(`Backup created: ${created.id}`);
            console.log(`Path: ${created.backupDir}`);
            console.log(`Files: ${created.files.map((f) => f.path).join(', ') || '-'}`);
        }
        return;
    }

    if (command === 'restore') {
        const asJson = args.includes('--json');
        const target = args.find((value) => !value.startsWith('--'));
        const lock = getLockStatus();

        if (lock.active) {
            console.error(
                `Cannot restore while bot is running (pid=${lock.pid}). Stop it first: nichebot stop`
            );
            process.exitCode = 1;
            return;
        }

        let backupId = target;
        if (!backupId || backupId === '--latest') {
            backupId = getLatestBackup()?.id || null;
        }

        if (!backupId) {
            console.error('No backup id provided and no backup found.');
            console.error('Usage: nichebot restore <backup-id>');
            process.exitCode = 1;
            return;
        }

        const restored = restoreRuntimeBackup(backupId, { createSafetyBackup: true });
        if (asJson) {
            console.log(JSON.stringify(restored, null, 2));
        } else {
            console.log(`Restore completed from backup: ${restored.backupId}`);
            console.log(`Restored paths: ${restored.restored.join(', ') || '-'}`);
            if (restored.preRestoreBackup) {
                console.log(`Safety backup created: ${restored.preRestoreBackup.id}`);
            }
        }
        return;
    }

    console.error(`Unknown command: ${command}`);
    printHelp();
    process.exitCode = 1;
}

main().catch((error) => {
    console.error('CLI failed:', error?.message || error);
    process.exit(1);
});
